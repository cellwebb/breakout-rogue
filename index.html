<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Breakout Rogue</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: "Courier New", monospace;
        color: #fff;
      }

      .game-container {
        position: relative;
        padding: 20px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 15px;
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
      }

      canvas {
        border: 2px solid #0ff;
        border-radius: 10px;
        display: block;
      }

      .ui-panel {
        position: absolute;
        top: 20px;
        right: -300px;
        width: 280px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #0ff;
        border-radius: 10px;
        padding: 15px;
      }

      .ui-panel h3 {
        color: #0ff;
        margin-bottom: 10px;
        text-align: center;
      }

      .stat {
        display: flex;
        justify-content: space-between;
        margin: 8px 0;
        font-size: 14px;
      }

      .stat-label {
        color: #888;
      }

      .stat-value {
        color: #0ff;
        font-weight: bold;
      }

      .upgrade-list {
        margin-top: 20px;
      }

      .upgrade-item {
        background: rgba(0, 255, 255, 0.1);
        border: 1px solid #088;
        border-radius: 5px;
        padding: 8px;
        margin: 8px 0;
        cursor: pointer;
        transition: all 0.3s;
      }

      .upgrade-item:hover {
        background: rgba(0, 255, 255, 0.2);
        border-color: #0ff;
      }

      .upgrade-item.purchased {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .upgrade-name {
        color: #0ff;
        font-size: 12px;
        font-weight: bold;
      }

      .upgrade-desc {
        color: #aaa;
        font-size: 11px;
        margin-top: 3px;
      }

      .upgrade-cost {
        color: #ffa500;
        font-size: 11px;
        margin-top: 3px;
      }

      .game-over-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #0ff;
        border-radius: 10px;
        padding: 30px;
        text-align: center;
        display: none;
      }

      .game-over-screen h2 {
        color: #0ff;
        margin-bottom: 20px;
      }

      .game-over-screen button {
        background: #0ff;
        color: #000;
        border: none;
        padding: 10px 30px;
        font-size: 16px;
        border-radius: 5px;
        cursor: pointer;
        margin: 10px;
        font-weight: bold;
        transition: all 0.3s;
      }

      .game-over-screen button:hover {
        background: #fff;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      }

      .start-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #0ff;
        border-radius: 10px;
        padding: 30px;
        text-align: center;
      }

      .start-screen h1 {
        color: #0ff;
        margin-bottom: 10px;
        font-size: 32px;
        text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      }

      .start-screen p {
        color: #aaa;
        margin: 10px 0;
        font-size: 14px;
      }

      .start-screen button {
        background: #0ff;
        color: #000;
        border: none;
        padding: 15px 40px;
        font-size: 18px;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 20px;
        font-weight: bold;
        transition: all 0.3s;
      }

      .start-screen button:hover {
        background: #fff;
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
      }

      .power-up-notification {
        position: absolute;
        top: 50px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 255, 255, 0.9);
        color: #000;
        padding: 10px 20px;
        border-radius: 5px;
        font-weight: bold;
        display: none;
        animation: slideDown 0.5s ease;
      }

      .pause-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #0ff;
        border-radius: 10px;
        padding: 40px;
        text-align: center;
        display: none;
        z-index: 1000;
      }

      .pause-screen h2 {
        color: #0ff;
        margin-bottom: 20px;
        font-size: 36px;
        text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      }

      .pause-screen p {
        color: #aaa;
        margin: 10px 0;
        font-size: 16px;
      }

      .pause-screen .controls {
        margin-top: 30px;
        padding-top: 20px;
        border-top: 1px solid #0ff;
      }

      .pause-screen .control-item {
        display: flex;
        justify-content: space-between;
        margin: 10px 0;
        color: #ccc;
      }

      .pause-screen .control-key {
        color: #0ff;
        font-weight: bold;
        min-width: 120px;
        text-align: left;
      }

      @keyframes slideDown {
        from {
          top: -50px;
          opacity: 0;
        }
        to {
          top: 50px;
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <canvas id="gameCanvas"></canvas>

      <div class="ui-panel">
        <h3>STATS</h3>
        <div class="stat">
          <span class="stat-label">Level:</span>
          <span class="stat-value" id="level">1</span>
        </div>
        <div class="stat">
          <span class="stat-label">Score:</span>
          <span class="stat-value" id="score">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Lives:</span>
          <span class="stat-value" id="lives">3</span>
        </div>
        <div class="stat">
          <span class="stat-label">Coins:</span>
          <span class="stat-value" id="coins">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Combo:</span>
          <span class="stat-value" id="combo">0x</span>
        </div>

        <div class="upgrade-list">
          <h3>UPGRADES</h3>
          <div id="upgradesList"></div>
        </div>
      </div>

      <div class="start-screen" id="startScreen">
        <h1>BREAKOUT ROGUE</h1>
        <p>A roguelike twist on the classic Breakout</p>
        <p>Destroy bricks, collect power-ups, and upgrade your paddle!</p>
        <p>Use ARROW KEYS or A/D to move • SPACE to launch • P or ESC to pause</p>
        <button onclick="startGame()">START GAME</button>
      </div>

      <div class="game-over-screen" id="gameOverScreen">
        <h2 id="gameOverTitle">GAME OVER</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Level Reached: <span id="finalLevel">1</span></p>
        <button onclick="restartGame()">RESTART</button>
        <button onclick="continueWithUpgrades()">
          CONTINUE (Keep Upgrades)
        </button>
      </div>

      <div class="power-up-notification" id="powerUpNotification"></div>
      
      <div class="pause-screen" id="pauseScreen">
        <h2>PAUSED</h2>
        <p>Press P or ESC to resume</p>
        
        <div class="controls">
          <h3 style="color: #0ff; margin-bottom: 15px;">CONTROLS</h3>
          <div class="control-item">
            <span class="control-key">← / → or A / D</span>
            <span>Move paddle</span>
          </div>
          <div class="control-item">
            <span class="control-key">SPACE</span>
            <span>Release ball</span>
          </div>
          <div class="control-item">
            <span class="control-key">P or ESC</span>
            <span>Pause/Resume</span>
          </div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      canvas.width = 800;
      canvas.height = 600;

      // Game state
      let gameRunning = false;
      let gamePaused = false;
      let level = 1;
      let score = 0;
      let lives = 3;
      let coins = 0;
      let combo = 0;
      let maxCombo = 0;

      // Paddle
      const paddle = {
        x: canvas.width / 2 - 75,
        y: canvas.height - 30,
        width: 150,
        height: 15,
        speed: 8,
        color: "#0ff",
        magnetism: false,
        magnetRange: 50,
        sticky: false,
      };

      // Ball
      const ball = {
        x: canvas.width / 2,
        y: paddle.y - 20,
        radius: 8,
        speedX: 4,
        speedY: -4,
        baseSpeed: 4,
        maxSpeed: 12,
        attached: true,
        trail: [],
        piercing: false,
        explosive: false,
        multiball: false,
      };

      // Additional balls for multiball
      let balls = [];

      // Bricks
      let bricks = [];
      const brickRows = 8;
      const brickCols = 10;
      const brickWidth = 70;
      const brickHeight = 20;
      const brickPadding = 5;
      const brickOffsetTop = 60;
      const brickOffsetLeft = 35;

      // Brick types with roguelike variety
      const brickTypes = {
        normal: { health: 1, color: "#ff6b6b", points: 10, coinChance: 0.1 },
        tough: { health: 2, color: "#4ecdc4", points: 20, coinChance: 0.15 },
        armored: { health: 3, color: "#95e1d3", points: 30, coinChance: 0.2 },
        golden: { health: 1, color: "#ffd700", points: 50, coinChance: 1 },
        explosive: { health: 1, color: "#ff4757", points: 15, coinChance: 0.1 },
        mystery: { health: 1, color: "#a29bfe", points: 25, coinChance: 0.3 },
      };

      // Power-ups
      const powerUps = [];
      const powerUpTypes = {
        multiball: { color: "#ff6b6b", duration: 0, text: "MULTI" },
        widen: { color: "#4ecdc4", duration: 10000, text: "WIDE" },
        slow: { color: "#95e1d3", duration: 8000, text: "SLOW" },
        pierce: { color: "#ffd700", duration: 7000, text: "PIERCE" },
        magnet: { color: "#a29bfe", duration: 10000, text: "MAGNET" },
        life: { color: "#26de81", duration: 0, text: "+LIFE" },
        coins: { color: "#ffd700", duration: 0, text: "+COINS" },
        explosive: { color: "#ff4757", duration: 5000, text: "BOOM" },
        sticky: { color: "#fd79a8", duration: 10000, text: "STICKY" },
      };

      // Active power-ups
      let activePowerUps = {};

      // Particles
      let particles = [];

      // Upgrades (Roguelike progression)
      const upgrades = [
        {
          id: "paddle_speed",
          name: "Swift Paddle",
          desc: "Increase paddle movement speed",
          cost: 50,
          maxLevel: 5,
          level: 0,
          apply: () => {
            paddle.speed += 2;
          },
        },
        {
          id: "ball_speed_control",
          name: "Speed Control",
          desc: "Better control over ball speed",
          cost: 75,
          maxLevel: 3,
          level: 0,
          apply: () => {
            ball.maxSpeed -= 1;
          },
        },
        {
          id: "extra_life",
          name: "Extra Life",
          desc: "Start with an additional life",
          cost: 100,
          maxLevel: 3,
          level: 0,
          apply: () => {
            lives += 1;
            updateUI();
          },
        },
        {
          id: "coin_magnet",
          name: "Coin Magnet",
          desc: "Increase coin drop rate",
          cost: 60,
          maxLevel: 5,
          level: 0,
          apply: () => {
            Object.keys(brickTypes).forEach((type) => {
              brickTypes[type].coinChance *= 1.2;
            });
          },
        },
        {
          id: "combo_master",
          name: "Combo Master",
          desc: "Combo multiplier increases faster",
          cost: 80,
          maxLevel: 3,
          level: 0,
          apply: () => {
            /* Applied in scoring logic */
          },
        },
        {
          id: "power_duration",
          name: "Power Extender",
          desc: "Power-ups last longer",
          cost: 90,
          maxLevel: 3,
          level: 0,
          apply: () => {
            Object.keys(powerUpTypes).forEach((type) => {
              if (powerUpTypes[type].duration > 0) {
                powerUpTypes[type].duration *= 1.25;
              }
            });
          },
        },
      ];

      // Controls
      const keys = {};
      document.addEventListener("keydown", (e) => {
        // Handle pause
        if ((e.key === "p" || e.key === "P" || e.key === "Escape") && gameRunning) {
          e.preventDefault();
          togglePause();
          return;
        }
        
        keys[e.key] = true;
        if (e.key === " " && ball.attached && gameRunning && !gamePaused) {
          releaseBall();
        }
      });
      document.addEventListener("keyup", (e) => {
        keys[e.key] = false;
      });

      // Toggle pause
      function togglePause() {
        gamePaused = !gamePaused;
        const pauseScreen = document.getElementById("pauseScreen");
        
        if (gamePaused) {
          pauseScreen.style.display = "block";
        } else {
          pauseScreen.style.display = "none";
          gameLoop(); // Resume game loop
        }
      }

      // Initialize bricks with roguelike generation
      function initBricks() {
        bricks = [];
        for (let r = 0; r < brickRows; r++) {
          for (let c = 0; c < brickCols; c++) {
            // Roguelike brick generation
            let type = "normal";
            const rand = Math.random();

            if (level > 1) {
              if (rand < 0.05 * Math.min(level / 5, 2)) type = "golden";
              else if (rand < 0.1 * Math.min(level / 3, 2)) type = "explosive";
              else if (rand < 0.15 * Math.min(level / 2, 2)) type = "mystery";
              else if (rand < 0.25 + level * 0.02) type = "armored";
              else if (rand < 0.4 + level * 0.03) type = "tough";
            } else {
              if (rand < 0.05) type = "golden";
              else if (rand < 0.15) type = "mystery";
              else if (rand < 0.3) type = "tough";
            }

            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;

            bricks.push({
              x: brickX,
              y: brickY,
              width: brickWidth,
              height: brickHeight,
              type: type,
              health: brickTypes[type].health,
              maxHealth: brickTypes[type].health,
              visible: true,
            });
          }
        }
      }

      // Release ball from paddle
      function releaseBall() {
        balls.forEach((b) => {
          if (b.attached) {
            b.attached = false;
            b.speedX = (Math.random() - 0.5) * 6;
            b.speedY = -Math.abs(b.baseSpeed);
          }
        });
      }

      // Update paddle
      function updatePaddle() {
        if (gamePaused) return; // Don't update when paused
        
        if (keys["ArrowLeft"] || keys["a"] || keys["A"]) {
          paddle.x = Math.max(0, paddle.x - paddle.speed);
        }
        if (keys["ArrowRight"] || keys["d"] || keys["D"]) {
          paddle.x = Math.min(
            canvas.width - paddle.width,
            paddle.x + paddle.speed,
          );
        }

        // Move attached balls with paddle
        balls.forEach((b) => {
          if (b.attached) {
            b.x = paddle.x + paddle.width / 2;
          }
        });
      }

      // Update ball
      function updateBall(b) {
        if (b.attached) return true; // Ball is attached, still in play

        // Add trail effect
        b.trail.push({ x: b.x, y: b.y, alpha: 1 });
        if (b.trail.length > 10) b.trail.shift();

        // Update trail
        b.trail.forEach((t) => (t.alpha *= 0.9));

        // Magnetism effect
        if (paddle.magnetism) {
          const dist = Math.abs(b.x - (paddle.x + paddle.width / 2));
          if (dist < paddle.magnetRange && b.y > paddle.y - 50) {
            b.speedX += (paddle.x + paddle.width / 2 - b.x) * 0.02;
          }
        }

        // Move ball
        b.x += b.speedX;
        b.y += b.speedY;

        // Speed limiting
        const currentSpeed = Math.sqrt(
          b.speedX * b.speedX + b.speedY * b.speedY,
        );
        if (currentSpeed > b.maxSpeed) {
          b.speedX = (b.speedX / currentSpeed) * b.maxSpeed;
          b.speedY = (b.speedY / currentSpeed) * b.maxSpeed;
        }

        // Wall collisions
        if (b.x + b.radius > canvas.width || b.x - b.radius < 0) {
          b.speedX = -b.speedX;
          createParticles(b.x, b.y, 5, "#0ff");
        }
        if (b.y - b.radius < 0) {
          b.speedY = -b.speedY;
          createParticles(b.x, b.y, 5, "#0ff");
        }

        // Paddle collision
        if (
          b.y + b.radius > paddle.y &&
          b.y - b.radius < paddle.y + paddle.height &&
          b.x > paddle.x &&
          b.x < paddle.x + paddle.width
        ) {
          if (paddle.sticky && !b.attached) {
            b.attached = true;
            b.y = paddle.y - b.radius - 1;
          } else {
            b.speedY = -Math.abs(b.speedY);
            // Add spin based on hit position
            const hitPos = (b.x - paddle.x) / paddle.width;
            b.speedX = 8 * (hitPos - 0.5);
            createParticles(b.x, b.y, 10, "#0ff");
            combo = 0; // Reset combo on paddle hit
          }
        }

        // Bottom boundary (lose life)
        if (b.y - b.radius > canvas.height) {
          return false; // Ball is lost
        }

        return true; // Ball is still in play
      }

      // Brick collision
      function checkBrickCollision(b) {
        for (let brick of bricks) {
          if (!brick.visible) continue;

          if (
            b.x + b.radius > brick.x &&
            b.x - b.radius < brick.x + brick.width &&
            b.y + b.radius > brick.y &&
            b.y - b.radius < brick.y + brick.height
          ) {
            // Damage brick
            brick.health--;

            // Explosive effect
            if (b.explosive || brick.type === "explosive") {
              explodeBricks(
                brick.x + brick.width / 2,
                brick.y + brick.height / 2,
              );
            }

            if (brick.health <= 0) {
              brick.visible = false;

              // Scoring with combo
              const comboMultiplier =
                1 +
                combo *
                  (upgrades.find((u) => u.id === "combo_master").level * 0.2 +
                    0.1);
              const points = Math.floor(
                brickTypes[brick.type].points * comboMultiplier,
              );
              score += points;
              combo++;
              if (combo > maxCombo) maxCombo = combo;

              // Coin drop
              if (Math.random() < brickTypes[brick.type].coinChance) {
                coins += Math.floor(Math.random() * 5) + 1;
                createParticles(
                  brick.x + brick.width / 2,
                  brick.y + brick.height / 2,
                  15,
                  "#ffd700",
                );
              }

              // Power-up drop
              if (Math.random() < 0.1 + level * 0.01) {
                spawnPowerUp(
                  brick.x + brick.width / 2,
                  brick.y + brick.height / 2,
                );
              }

              // Mystery brick effect
              if (brick.type === "mystery") {
                const surprise = Math.random();
                if (surprise < 0.3) {
                  spawnPowerUp(
                    brick.x + brick.width / 2,
                    brick.y + brick.height / 2,
                  );
                } else if (surprise < 0.6) {
                  coins += 10;
                  showNotification("+10 COINS!");
                } else {
                  score += 100;
                  showNotification("+100 BONUS!");
                }
              }

              createParticles(
                brick.x + brick.width / 2,
                brick.y + brick.height / 2,
                20,
                brickTypes[brick.type].color,
              );
            }

            // Ball bounce (unless piercing)
            if (!b.piercing) {
              // Determine which side was hit
              const ballCenterX = b.x;
              const ballCenterY = b.y;
              const brickCenterX = brick.x + brick.width / 2;
              const brickCenterY = brick.y + brick.height / 2;

              const dx = ballCenterX - brickCenterX;
              const dy = ballCenterY - brickCenterY;

              if (Math.abs(dx) > Math.abs(dy)) {
                b.speedX = -b.speedX;
              } else {
                b.speedY = -b.speedY;
              }
            }

            updateUI();
            break;
          }
        }
      }

      // Explode nearby bricks
      function explodeBricks(x, y) {
        const radius = 100;
        for (let brick of bricks) {
          if (!brick.visible) continue;
          const dx = brick.x + brick.width / 2 - x;
          const dy = brick.y + brick.height / 2 - y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < radius) {
            brick.health = Math.max(0, brick.health - 2);
            if (brick.health <= 0) {
              brick.visible = false;
              score += brickTypes[brick.type].points;
              createParticles(
                brick.x + brick.width / 2,
                brick.y + brick.height / 2,
                10,
                brickTypes[brick.type].color,
              );
            }
          }
        }
        createParticles(x, y, 50, "#ff4757");
      }

      // Spawn power-up
      function spawnPowerUp(x, y) {
        const types = Object.keys(powerUpTypes);
        const type = types[Math.floor(Math.random() * types.length)];
        powerUps.push({
          x: x,
          y: y,
          width: 30,
          height: 20,
          type: type,
          speed: 2,
        });
      }

      // Update power-ups
      function updatePowerUps() {
        for (let i = powerUps.length - 1; i >= 0; i--) {
          const pu = powerUps[i];
          pu.y += pu.speed;

          // Catch power-up
          if (
            pu.y + pu.height > paddle.y &&
            pu.y < paddle.y + paddle.height &&
            pu.x + pu.width > paddle.x &&
            pu.x < paddle.x + paddle.width
          ) {
            activatePowerUp(pu.type);
            powerUps.splice(i, 1);
            continue;
          }

          // Remove if off screen
          if (pu.y > canvas.height) {
            powerUps.splice(i, 1);
          }
        }
      }

      // Activate power-up
      function activatePowerUp(type) {
        showNotification(powerUpTypes[type].text);
        createParticles(
          paddle.x + paddle.width / 2,
          paddle.y,
          20,
          powerUpTypes[type].color,
        );

        switch (type) {
          case "multiball":
            const newBalls = [];
            balls.forEach((b) => {
              for (let i = 0; i < 2; i++) {
                const newBall = {
                  x: b.x,
                  y: b.y,
                  radius: b.radius,
                  speedX: b.speedX + (Math.random() - 0.5) * 4,
                  speedY: b.speedY + (Math.random() - 0.5) * 2,
                  baseSpeed: b.baseSpeed,
                  maxSpeed: b.maxSpeed,
                  attached: false,
                  trail: [],
                  piercing: b.piercing,
                  explosive: b.explosive,
                };
                newBalls.push(newBall);
              }
            });
            balls.push(...newBalls);
            break;

          case "widen":
            clearTimeout(activePowerUps.widen);
            paddle.width = 200;
            activePowerUps.widen = setTimeout(() => {
              paddle.width = 150;
              delete activePowerUps.widen;
            }, powerUpTypes.widen.duration);
            break;

          case "slow":
            clearTimeout(activePowerUps.slow);
            balls.forEach((b) => {
              b.speedX *= 0.5;
              b.speedY *= 0.5;
            });
            activePowerUps.slow = setTimeout(() => {
              balls.forEach((b) => {
                b.speedX *= 2;
                b.speedY *= 2;
              });
              delete activePowerUps.slow;
            }, powerUpTypes.slow.duration);
            break;

          case "pierce":
            clearTimeout(activePowerUps.pierce);
            balls.forEach((b) => (b.piercing = true));
            activePowerUps.pierce = setTimeout(() => {
              balls.forEach((b) => (b.piercing = false));
              delete activePowerUps.pierce;
            }, powerUpTypes.pierce.duration);
            break;

          case "magnet":
            clearTimeout(activePowerUps.magnet);
            paddle.magnetism = true;
            activePowerUps.magnet = setTimeout(() => {
              paddle.magnetism = false;
              delete activePowerUps.magnet;
            }, powerUpTypes.magnet.duration);
            break;

          case "life":
            lives++;
            updateUI();
            break;

          case "coins":
            coins += 20 + Math.floor(Math.random() * 30);
            updateUI();
            break;

          case "explosive":
            clearTimeout(activePowerUps.explosive);
            balls.forEach((b) => (b.explosive = true));
            activePowerUps.explosive = setTimeout(() => {
              balls.forEach((b) => (b.explosive = false));
              delete activePowerUps.explosive;
            }, powerUpTypes.explosive.duration);
            break;

          case "sticky":
            clearTimeout(activePowerUps.sticky);
            paddle.sticky = true;
            activePowerUps.sticky = setTimeout(() => {
              paddle.sticky = false;
              delete activePowerUps.sticky;
            }, powerUpTypes.sticky.duration);
            break;
        }
      }

      // Create particles
      function createParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
          particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8,
            alpha: 1,
            color: color,
            size: Math.random() * 4 + 2,
          });
        }
      }

      // Update particles
      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.2; // Gravity
          p.alpha -= 0.02;
          p.size *= 0.98;

          if (p.alpha <= 0) {
            particles.splice(i, 1);
          }
        }
      }

      // Draw functions
      function drawPaddle() {
        // Glow effect
        ctx.shadowBlur = 20;
        ctx.shadowColor = paddle.color;

        const gradient = ctx.createLinearGradient(
          paddle.x,
          paddle.y,
          paddle.x,
          paddle.y + paddle.height,
        );
        gradient.addColorStop(
          0,
          paddle.magnetism ? "#a29bfe" : paddle.sticky ? "#fd79a8" : "#0ff",
        );
        gradient.addColorStop(
          1,
          paddle.magnetism ? "#6c5ce7" : paddle.sticky ? "#e84393" : "#0088cc",
        );

        ctx.fillStyle = gradient;
        ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

        // Edge highlights
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);

        ctx.shadowBlur = 0;
      }

      function drawBall(b) {
        // Trail effect
        b.trail.forEach((t, i) => {
          ctx.globalAlpha = t.alpha * 0.3;
          ctx.fillStyle = b.explosive
            ? "#ff4757"
            : b.piercing
              ? "#ffd700"
              : "#fff";
          ctx.beginPath();
          ctx.arc(t.x, t.y, b.radius * (1 - i * 0.05), 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Main ball with glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = b.explosive
          ? "#ff4757"
          : b.piercing
            ? "#ffd700"
            : "#0ff";

        const gradient = ctx.createRadialGradient(
          b.x,
          b.y,
          0,
          b.x,
          b.y,
          b.radius,
        );
        gradient.addColorStop(0, "#fff");
        gradient.addColorStop(
          0.5,
          b.explosive ? "#ff6b6b" : b.piercing ? "#ffd700" : "#0ff",
        );
        gradient.addColorStop(
          1,
          b.explosive ? "#ff4757" : b.piercing ? "#f0932b" : "#0088cc",
        );

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
      }

      function drawBricks() {
        for (let brick of bricks) {
          if (!brick.visible) continue;

          const type = brick.type;
          const color = brickTypes[type].color;

          // Damaged effect
          const damageRatio = brick.health / brick.maxHealth;

          // Glow for special bricks
          if (type === "golden" || type === "mystery") {
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
          }

          // Main brick
          const gradient = ctx.createLinearGradient(
            brick.x,
            brick.y,
            brick.x,
            brick.y + brick.height,
          );
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, adjustColor(color, -30));

          ctx.fillStyle = gradient;
          ctx.globalAlpha = 0.7 + damageRatio * 0.3;
          ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
          ctx.globalAlpha = 1;

          // Cracks for damaged bricks
          if (brick.health < brick.maxHealth) {
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            ctx.globalAlpha = 1 - damageRatio;

            // Draw crack lines
            ctx.beginPath();
            ctx.moveTo(brick.x + brick.width * 0.3, brick.y);
            ctx.lineTo(brick.x + brick.width * 0.4, brick.y + brick.height);
            ctx.moveTo(brick.x + brick.width * 0.7, brick.y);
            ctx.lineTo(brick.x + brick.width * 0.6, brick.y + brick.height);
            ctx.stroke();
            ctx.globalAlpha = 1;
          }

          // Border
          ctx.strokeStyle = adjustColor(color, 20);
          ctx.lineWidth = 2;
          ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

          // Type indicator
          if (type === "golden") {
            ctx.fillStyle = "#fff";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "center";
            ctx.fillText(
              "$",
              brick.x + brick.width / 2,
              brick.y + brick.height / 2 + 4,
            );
          } else if (type === "explosive") {
            ctx.fillStyle = "#fff";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "center";
            ctx.fillText(
              "💥",
              brick.x + brick.width / 2,
              brick.y + brick.height / 2 + 4,
            );
          } else if (type === "mystery") {
            ctx.fillStyle = "#fff";
            ctx.font = "bold 14px Arial";
            ctx.textAlign = "center";
            ctx.fillText(
              "?",
              brick.x + brick.width / 2,
              brick.y + brick.height / 2 + 5,
            );
          }

          ctx.shadowBlur = 0;
        }
      }

      function drawPowerUps() {
        for (let pu of powerUps) {
          const type = powerUpTypes[pu.type];

          // Glow effect
          ctx.shadowBlur = 15;
          ctx.shadowColor = type.color;

          // Background
          ctx.fillStyle = type.color;
          ctx.globalAlpha = 0.8;
          ctx.fillRect(pu.x, pu.y, pu.width, pu.height);

          // Border
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.strokeRect(pu.x, pu.y, pu.width, pu.height);

          // Text
          ctx.globalAlpha = 1;
          ctx.fillStyle = "#fff";
          ctx.font = "bold 10px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            type.text,
            pu.x + pu.width / 2,
            pu.y + pu.height / 2 + 3,
          );

          ctx.shadowBlur = 0;
        }
      }

      function drawParticles() {
        for (let p of particles) {
          ctx.globalAlpha = p.alpha;
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        }
        ctx.globalAlpha = 1;
      }

      function drawBackground() {
        // Animated gradient background
        const time = Date.now() * 0.0001;
        const gradient = ctx.createLinearGradient(
          0,
          0,
          canvas.width,
          canvas.height,
        );
        gradient.addColorStop(0, `hsl(${220 + Math.sin(time) * 20}, 30%, 10%)`);
        gradient.addColorStop(1, `hsl(${240 + Math.cos(time) * 20}, 30%, 20%)`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Grid effect
        ctx.strokeStyle = "rgba(0, 255, 255, 0.05)";
        ctx.lineWidth = 1;
        for (let i = 0; i < canvas.width; i += 50) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, canvas.height);
          ctx.stroke();
        }
        for (let i = 0; i < canvas.height; i += 50) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(canvas.width, i);
          ctx.stroke();
        }
      }

      // Color adjustment helper
      function adjustColor(color, amount) {
        const num = parseInt(color.replace("#", ""), 16);
        const r = Math.min(255, Math.max(0, (num >> 16) + amount));
        const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00ff) + amount));
        const b = Math.min(255, Math.max(0, (num & 0x0000ff) + amount));
        return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, "0")}`;
      }

      // Show notification
      function showNotification(text) {
        const notif = document.getElementById("powerUpNotification");
        notif.textContent = text;
        notif.style.display = "block";
        setTimeout(() => {
          notif.style.display = "none";
        }, 2000);
      }

      // Update UI
      function updateUI() {
        document.getElementById("level").textContent = level;
        document.getElementById("score").textContent = score;
        document.getElementById("lives").textContent = lives;
        document.getElementById("coins").textContent = coins;
        document.getElementById("combo").textContent = combo + "x";

        // Update upgrades list
        const upgradesList = document.getElementById("upgradesList");
        upgradesList.innerHTML = "";

        upgrades.forEach((upgrade) => {
          const div = document.createElement("div");
          div.className = "upgrade-item";
          if (upgrade.level >= upgrade.maxLevel) {
            div.classList.add("purchased");
          }

          div.innerHTML = `
                    <div class="upgrade-name">${upgrade.name} (${upgrade.level}/${upgrade.maxLevel})</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                    <div class="upgrade-cost">Cost: ${upgrade.cost * (upgrade.level + 1)} coins</div>
                `;

          div.onclick = () => purchaseUpgrade(upgrade);
          upgradesList.appendChild(div);
        });
      }

      // Purchase upgrade
      function purchaseUpgrade(upgrade) {
        const cost = upgrade.cost * (upgrade.level + 1);
        if (coins >= cost && upgrade.level < upgrade.maxLevel) {
          coins -= cost;
          upgrade.level++;
          upgrade.apply();
          updateUI();
          showNotification(`Purchased ${upgrade.name}!`);
        }
      }

      // Game loop
      function gameLoop() {
        if (!gameRunning || gamePaused) return;

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw everything
        drawBackground();
        drawBricks();
        drawPowerUps();
        drawPaddle();
        balls.forEach((b) => drawBall(b));
        drawParticles();

        // Update game objects
        updatePaddle();

        // Update balls
        for (let i = balls.length - 1; i >= 0; i--) {
          if (!updateBall(balls[i])) {
            balls.splice(i, 1);
          } else {
            checkBrickCollision(balls[i]);
          }
        }

        // Check if all balls are lost
        if (balls.length === 0) {
          lives--;
          updateUI();

          if (lives <= 0) {
            gameOver();
          } else {
            // Reset ball
            balls = [
              {
                x: canvas.width / 2,
                y: paddle.y - 20,
                radius: 8,
                speedX: 4,
                speedY: -4,
                baseSpeed: 4 + level * 0.5,
                maxSpeed: 12,
                attached: true,
                trail: [],
                piercing: false,
                explosive: false,
              },
            ];
            combo = 0;
          }
        }

        updatePowerUps();
        updateParticles();

        // Check level completion
        if (bricks.every((b) => !b.visible)) {
          nextLevel();
        }

        requestAnimationFrame(gameLoop);
      }

      // Next level
      function nextLevel() {
        level++;
        balls = [
          {
            x: canvas.width / 2,
            y: paddle.y - 20,
            radius: 8,
            speedX: 4,
            speedY: -4,
            baseSpeed: 4 + level * 0.5,
            maxSpeed: 12,
            attached: true,
            trail: [],
            piercing: false,
            explosive: false,
          },
        ];

        // Clear power-ups but keep upgrades
        powerUps.length = 0;
        Object.keys(activePowerUps).forEach((key) => {
          clearTimeout(activePowerUps[key]);
        });
        activePowerUps = {};

        initBricks();
        combo = 0;

        showNotification(`LEVEL ${level}!`);
        updateUI();
      }

      // Game over
      function gameOver() {
        gameRunning = false;
        document.getElementById("finalScore").textContent = score;
        document.getElementById("finalLevel").textContent = level;
        document.getElementById("gameOverScreen").style.display = "block";
      }

      // Start game
      function startGame() {
        document.getElementById("startScreen").style.display = "none";

        // Initialize ball properly
        balls = [
          {
            x: canvas.width / 2,
            y: paddle.y - 20,
            radius: 8,
            speedX: 4,
            speedY: -4,
            baseSpeed: 4,
            maxSpeed: 12,
            attached: true,
            trail: [],
            piercing: false,
            explosive: false,
          },
        ];

        gameRunning = true;
        initBricks();
        updateUI();
        gameLoop();
      }

      // Restart game
      function restartGame() {
        // Reset everything
        level = 1;
        score = 0;
        lives = 3;
        coins = 0;
        combo = 0;

        // Reset upgrades
        upgrades.forEach((u) => (u.level = 0));

        // Reset paddle
        paddle.x = canvas.width / 2 - 75;
        paddle.width = 150;
        paddle.speed = 8;
        paddle.magnetism = false;
        paddle.sticky = false;

        // Reset balls
        balls = [
          {
            x: canvas.width / 2,
            y: paddle.y - 20,
            radius: 8,
            speedX: 4,
            speedY: -4,
            baseSpeed: 4,
            maxSpeed: 12,
            attached: true,
            trail: [],
            piercing: false,
            explosive: false,
          },
        ];

        // Clear power-ups
        powerUps.length = 0;
        particles.length = 0;
        Object.keys(activePowerUps).forEach((key) => {
          clearTimeout(activePowerUps[key]);
        });
        activePowerUps = {};

        document.getElementById("gameOverScreen").style.display = "none";
        gameRunning = true;
        initBricks();
        updateUI();
        gameLoop();
      }

      // Continue with upgrades
      function continueWithUpgrades() {
        // Keep upgrades and coins, reset other stats
        level = 1;
        score = 0;
        lives = 3;
        combo = 0;

        // Reset paddle position but keep upgrades
        paddle.x = canvas.width / 2 - 75;

        // Reset balls
        balls = [
          {
            x: canvas.width / 2,
            y: paddle.y - 20,
            radius: 8,
            speedX: 4,
            speedY: -4,
            baseSpeed: 4,
            maxSpeed:
              12 - upgrades.find((u) => u.id === "ball_speed_control").level,
            attached: true,
            trail: [],
            piercing: false,
            explosive: false,
          },
        ];

        // Clear power-ups
        powerUps.length = 0;
        particles.length = 0;
        Object.keys(activePowerUps).forEach((key) => {
          clearTimeout(activePowerUps[key]);
        });
        activePowerUps = {};

        // Apply passive upgrades
        upgrades.forEach((u) => {
          if (u.id === "extra_life" && u.level > 0) {
            lives = 3 + u.level;
          }
        });

        document.getElementById("gameOverScreen").style.display = "none";
        gameRunning = true;
        initBricks();
        updateUI();
        gameLoop();
      }

      // Initialize
      updateUI();
    </script>
  </body>
</html>
